---
title: "定点数和浮点数，定点小数和定点整数"
date: 2018-04-23T21:38:52+08:00
lastmod: 2018-04-23T21:41:52+08:00
menu: "main"
weight: 50
author: "hansenbeast"
tags: [
    "Computer Organization Design"
]
categories: [
    "Basic Concepts"
]
# you can close something for this content if you open it in config.toml.
comment: false
mathjax: false
---

# 定点数和浮点数：

定点数小数位数不变，浮点数可移位变化小数位数

定点小数小数点左边一位为符号位，右边为真值。小数点固定在最高位之后称为[定点小数](https://baike.baidu.com/item/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0)。若机器字长为n+1位，数值表示为：


$$
X=X0.X1X2...Xn代表的小数为 (-1)^X0* ((X1*2^(-1）） + X22^(-2） + ... + Xn-12^(-n+1） + Xn2^(-n))
$$
定点整数，小数点位固定在最后一位之后。若机器字长为n+1位，数值表示为：


$$
X=X0X1X2...Xn，其中Xi={0,1},0≤i≤n 即（-1）^X0 *(X1*2^(n-1） + X2*2^(n-2） + ... + Xn-1*2 + Xn)
$$


**8位字长定点小数补码的范围：-1~127（真值），（1.0000000~0.1111111）**

```
定点数
    所谓定点数是指小数点位置固定不变的数。在计算机中，通常用定点数来表示整数与纯小数，分别称为定点整数与定点小数。
    定点整数：一个数的最高二进制位是数符位，用以表示数的符号；而小数点的位置默认为在最低(即最右边）的二进制位的后面，但小数点不单独占一个二进制位，如下所示:
            0          1001010010001010001           
         数符位            数值位                  小数位
因此，在一个定点整数中，数符位右边的所有二进制位数表示的是一个整数值。
```

```
  定点小数：一个数的最高二进制位是数符位，用来表示数的符号；而小数点的位置默认为在数符位后面，不单独占一个二进制位，如图所示：
             0               1001010010001010001
           数符位|小数位         数值位               
因此，在一个定点小数中，数符位右边的所有二进制位数表示的是一个纯小数。
```



转自：https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html

#  机器数和真值:

原码, 反码, 补码是机器存储一个具体数字的编码方式.(机器数)



原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值.



反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.



补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)



原码计算：1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

反码计算：1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反= [1111 1111]反 = [1000 0000]原 = -0



补码的出现, 解决了0的符号以及两个编码的问题:

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补= [0000 0000]补=[0000 0000]原



**使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].**

(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补



补码加法：

[X+Y]补 = [X]补 + [Y]补

例X=+0110011,Y=-0101001，求[X+Y]补

[X]补=00110011 [Y]补=11010111

[X+Y]补 = [X]补 + [Y]补 = 00110011+11010111=00001010

注：因为计算机中运算器的位长是固定的（定长运算），上述运算中产生的最高位进位将丢掉，所以结果不是100001010，而是00001010。



补码减法：

[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补

例：1-1 [十进制]

1的原码00000001 转换成补码：00000001

-1的原码10000001 转换成补码：11111111

1+（-1)=0

00000001+11111111=00000000

00000000转换成十进制为0

0=0所以运算正确。

【例8增】-7-（-10) [十进制]

改为加法形式：-7-（-10）=-7+（-（-10））

-7的补码：11111001

-（-10）的补码：-10的原码为10001010，-（-10）的原码为00001010，

-（-10）的补码就是其原码，为00001010

-7 - （-10)= -7 + 10 = 3

11111001+00001010 = 00000011

转换成十进制为3



https://www.cnblogs.com/reasno/p/4864874.html

# 规格化

https://blog.csdn.net/liutianshx2012/article/details/50731280

https://blog.csdn.net/coder85/article/details/46128771



